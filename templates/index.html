<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cucumber Freshness Detector</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0 auto; max-width: 900px; padding: 24px; }
    h1 { margin: 0 0 8px; }
    p.sub { color: #666; margin-top: 0; }
    .wrap { display: grid; grid-template-columns: 1fr; gap: 16px; }
    .panel { border: 1px solid #e5e5e5; border-radius: 10px; padding: 16px; }
    video, canvas { width: 100%; max-width: 640px; border-radius: 8px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0; }
    button { padding: 10px 16px; border-radius: 8px; border: 1px solid #ccc; background: #fafafa; cursor: pointer; }
    button.primary { background: #0ea5e9; color: white; border: none; }
    .result { padding: 12px; border-radius: 8px; background: #f5f5f5; }
    .fresh { background: #d4edda; }
    .wilted { background: #f8d7da; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; align-items: start; }
    @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }
    .legend { font-size: 14px; color: #444; }
  </style>
  <meta name="color-scheme" content="light dark" />
  <script>
    const API_PREDICT = '/predict';
  </script>
</head>
<body>
  <h1>ü•í Cucumber Freshness Detector</h1>
  <p class="sub">Use your camera or upload an image to detect if a cucumber is fresh or wilted.</p>

  <div class="wrap">
    <div class="panel">
      <div class="row">
        <div>
          <video id="video" autoplay playsinline muted></video>
          <canvas id="canvas" style="display:none;"></canvas>
          <div class="controls">
            <button id="start" class="primary">Start Camera</button>
            <button id="capture" class="primary">Capture & Analyze</button>
            <button id="switch" class="primary">Switch Camera</button>
            <button id="upload" class="primary">Upload Image</button>
            <input class="primary" id="file" type="file" accept="image/*" style="display:none;" />
          </div>
          <div class="legend">Tip: On mobile, Start Camera will use the back camera when available.</div>
        </div>
        <div>
          <canvas id="preview" width="640" height="480"></canvas>
          <div id="result" class="result" style="display:none; margin-top:8px;"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const preview = document.getElementById('preview');
    const pctx = preview.getContext('2d');
    const startBtn = document.getElementById('start');
    const captureBtn = document.getElementById('capture');
    const switchBtn = document.getElementById('switch');
    const uploadBtn = document.getElementById('upload');
    const fileInput = document.getElementById('file');
    const resultBox = document.getElementById('result');

    let currentStream = null;
    let useBackCamera = true;

    function stopStream() {
      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
    }

    async function startCamera() {
      try {
        stopStream();
        const constraints = {
          video: { facingMode: useBackCamera ? { ideal: 'environment' } : 'user' },
          audio: false
        };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
      } catch (err) {
        alert('Unable to access camera: ' + err.message);
      }
    }

    function drawDetections(img, detections) {
      pctx.drawImage(img, 0, 0, preview.width, preview.height);
      if (!detections) return;
      pctx.lineWidth = 2;
      detections.forEach(det => {
        const [x1, y1, x2, y2] = det.bbox;
        const w = x2 - x1;
        const h = y2 - y1;
        pctx.strokeStyle = det.class === 'fresh cucumber' ? '#16a34a' : '#dc2626';
        pctx.fillStyle = pctx.strokeStyle;
        pctx.strokeRect(x1, y1, w, h);
        const label = `${det.class} ${(det.confidence*100).toFixed(1)}%`;
        const pad = 4; const lh = 18;
        pctx.fillRect(x1, Math.max(0, y1 - lh), pctx.measureText(label).width + pad*2, lh);
        pctx.fillStyle = '#ffffff';
        pctx.font = '14px system-ui';
        pctx.fillText(label, x1 + pad, Math.max(12, y1 - 4));
      });
    }

    async function sendToServer(dataUrl) {
      const res = await fetch(API_PREDICT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image: dataUrl })
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || ('HTTP ' + res.status));
      }
      return res.json();
    }

    async function analyzeImage(img) {
      // Fit preview canvas size to image
      preview.width = img.width;
      preview.height = img.height;
      pctx.drawImage(img, 0, 0);
      const dataUrl = preview.toDataURL('image/jpeg', 0.9);
      resultBox.style.display = 'block';
      resultBox.textContent = 'Analyzing...';
      resultBox.className = 'result';

      try {
        const result = await sendToServer(dataUrl);
        drawDetections(img, result.all_detections);
        if (result.prediction && result.prediction !== 'No cucumber detected') {
          const isFresh = result.is_fresh;
          resultBox.className = 'result ' + (isFresh ? 'fresh' : 'wilted');
          resultBox.innerHTML = `<strong>${isFresh ? '‚úÖ Fresh' : '‚ùå Wilted'}</strong> ‚Äî Confidence ${(result.confidence*100).toFixed(1)}%`;
        } else {
          resultBox.className = 'result';
          resultBox.textContent = 'No cucumber detected';
        }
      } catch (e) {
        resultBox.className = 'result';
        resultBox.textContent = 'Error: ' + e.message;
      }
    }

    startBtn.addEventListener('click', startCamera);
    switchBtn.addEventListener('click', () => { useBackCamera = !useBackCamera; startCamera(); });
    captureBtn.addEventListener('click', async () => {
      if (!currentStream) { alert('Start the camera first'); return; }
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const cctx = canvas.getContext('2d');
      cctx.drawImage(video, 0, 0);
      const img = new Image();
      img.onload = () => analyzeImage(img);
      img.src = canvas.toDataURL('image/jpeg', 0.9);
    });
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      const f = fileInput.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => { const img = new Image(); img.onload = () => analyzeImage(img); img.src = reader.result; };
      reader.readAsDataURL(f);
    });
  </script>
</body>
</html>
